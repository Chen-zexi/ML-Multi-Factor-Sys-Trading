# %%
import pandas as pd
import sys
import os
sys.path.append(os.path.abspath(''))
# Define input and output file paths
input_csv_path = 'data/news/nasdaq_news_data_cleaned.csv'
output_csv_path = 'data/news/nasdaq_news_data_processed.csv'

print(f"Reading data from: {input_csv_path}")

try:
    # Read the CSV file generated by extrac_data.py
    df = pd.read_csv(input_csv_path)

    print("Data loaded successfully.")

    # Define required and final columns
    required_columns = ['Date', 'Ticker', 'Article_title', 'Lexrank_summary']
    final_columns_order = ['UID', 'Date', 'Ticker', 'Title', 'Summary']
    rename_mapping = {
        'Article_title': 'Title',
        'Lexrank_summary': 'Summary'
    }

    # Check if required columns exist
    missing_cols = [col for col in required_columns if col not in df.columns]
    if missing_cols:
        print(f"Error: Missing required columns in input file: {missing_cols}")
        # Optionally raise an error or exit
        # raise ValueError(f"Missing columns: {missing_cols}")
    else:
        # Convert 'Date' to datetime objects for proper sorting
        # Use errors='coerce' to handle any potential formatting issues gracefully
        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')

        # Drop rows where date conversion failed (optional, but good practice)
        initial_rows = len(df)
        df.dropna(subset=['Date'], inplace=True)
        if len(df) < initial_rows:
            print(f"Dropped {initial_rows - len(df)} rows due to invalid date format.")

        # Sort the DataFrame by Date
        print("Sorting data by date...")
        df_sorted = df.sort_values(by='Date').reset_index(drop=True)

        # Add UID column
        df_sorted['UID'] = df_sorted.index + 1

        # Select only the required columns + UID
        df_selected = df_sorted[required_columns + ['UID']].copy()

        # Rename columns
        print("Renaming columns...")
        df_renamed = df_selected.rename(columns=rename_mapping)

        # Reorder columns to the desired final order (optional but good practice)
        df_final = df_renamed[final_columns_order]

        # Save the processed data to a new CSV file
        print(f"Saving processed data to: {output_csv_path}")
        df_final.to_csv(output_csv_path, index=False, date_format='%Y-%m-%d')

        print("Processing complete.")
        print(f"Final data shape: {df_final.shape}")
        print("Final DataFrame head:")
        print(df_final.head())


except FileNotFoundError:
    print(f"Error: Input file not found at {input_csv_path}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

# %% 